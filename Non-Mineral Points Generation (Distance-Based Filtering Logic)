Non-mineral points generation (Fixed logic)

Logic (distance to mineral points):
  0-10 m   : delete 100%
  10-20 m  : delete 80%
  20-35 m  : delete 60%
  35-50 m  : delete 40%
  50-70 m  : delete 20%
  >=70 m   : delete 0% (keep all)

Grid spacing: 5 meters (configurable)
"""

from __future__ import annotations

import os
import re
import math
import time
import random
import logging
from dataclasses import dataclass
from typing import List, Tuple, Optional

import arcpy


# ----------------------------
# Config
# ----------------------------

@dataclass(frozen=True)
class NMConfig:
    base_workspace: str                # folder workspace (not necessarily a gdb)
    input_raster_gdb: str              # lithology rasters gdb
    sample_points_gdb: str             # mineral points gdb (o*)
    output_gdb: str                    # where to write n* points (can be same as input)

    raster_filter_enabled: bool = True
    raster_filter_text: str = "ColorRaster"  # or "Reclassify", etc.

    grid_spacing_m: float = 5.0

    # (min_dist, max_dist, delete_ratio)
    distance_zones: Tuple[Tuple[float, float, float], ...] = (
        (0.0, 10.0, 1.00),
        (10.0, 20.0, 0.80),
        (20.0, 35.0, 0.60),
        (35.0, 50.0, 0.40),
        (50.0, 70.0, 0.20),
    )

    # systematic removal: every k-th point approx
    removal_method: str = "systematic"  # "systematic" or "random"
    seed: int = 42


def configure_logging(level=logging.INFO) -> None:
    logging.basicConfig(level=level, format="%(asctime)s | %(levelname)s | %(message)s")


def safe_delete(path: str) -> None:
    try:
        if arcpy.Exists(path):
            arcpy.Delete_management(path)
    except Exception:
        pass


def ensure_gdb(gdb_path: str) -> None:
    if arcpy.Exists(gdb_path):
        return
    folder = os.path.dirname(gdb_path)
    name = os.path.basename(gdb_path)
    arcpy.CreateFileGDB_management(folder, name)


def extract_height_from_name(name: str) -> Optional[str]:
    """
    Extract height token like 12_5 or 15 from names.
    Returns normalized string with '.' instead of '_' (e.g., '12.5').
    """
    m = re.search(r"(?:f|b)?(\d+(?:_\d+)?)", name)
    if not m:
        return None
    return m.group(1).replace("_", ".")


def list_rasters(cfg: NMConfig) -> List[dict]:
    arcpy.env.workspace = cfg.input_raster_gdb
    rasters = arcpy.ListRasters() or []
    out = []
    for r in rasters:
        if cfg.raster_filter_enabled:
            if cfg.raster_filter_text and (cfg.raster_filter_text not in r):
                continue
        h = extract_height_from_name(r) or r
        out.append({"name": r, "path": os.path.join(cfg.input_raster_gdb, r), "height": h})
    return out


def list_mineral_point_fcs(cfg: NMConfig) -> List[dict]:
    arcpy.env.workspace = cfg.sample_points_gdb
    fcs = arcpy.ListFeatureClasses("o*", "Point") or []
    out = []
    for fc in fcs:
        # height often appears as o12_5 etc
        m = re.search(r"o(\d+(?:_\d+)?)", fc)
        if m:
            h = m.group(1).replace("_", ".")
        else:
            h = extract_height_from_name(fc) or fc
        out.append({"name": fc, "path": os.path.join(cfg.sample_points_gdb, fc), "height": h})
    return out


def match_pairs(rasters: List[dict], points: List[dict]) -> List[dict]:
    pairs = []
    for r in rasters:
        for p in points:
            if r["height"] == p["height"]:
                pairs.append({"height": r["height"], "raster": r, "points": p})
    return pairs


def _systematic_keep_mask(n: int, delete_ratio: float) -> List[bool]:
    """
    Return list[bool] of length n indicating keep(True)/delete(False)
    for systematic deletion. Approximate delete_ratio.
    """
    if n <= 0:
        return []
    if delete_ratio <= 0:
        return [True] * n
    if delete_ratio >= 1:
        return [False] * n

    delete_count = int(round(n * delete_ratio))
    keep = [True] * n
    if delete_count <= 0:
        return keep

    step = n / delete_count
    # delete indices: 0, step, 2*step, ...
    idx = 0.0
    deleted = 0
    while deleted < delete_count:
        i = int(idx)
        if i >= n:
            break
        keep[i] = False
        deleted += 1
        idx += step
    return keep


def create_fixed_nonmineral_points(
    raster_path: str,
    mineral_points_fc: str,
    output_fc: str,
    cfg: NMConfig,
) -> tuple[str, int, int]:
    """
    Returns (output_fc, final_count, initial_count)
    """
    random.seed(cfg.seed)

    raster = arcpy.Raster(raster_path)
    desc = arcpy.Describe(raster)
    extent = desc.extent
    sr = desc.spatialReference

    safe_delete(output_fc)
    arcpy.CreateFeatureclass_management(os.path.dirname(output_fc), os.path.basename(output_fc), "POINT", spatial_reference=sr)

    width = float(extent.XMax - extent.XMin)
    height = float(extent.YMax - extent.YMin)

    cols = int(width / cfg.grid_spacing_m) + 1
    rows = int(height / cfg.grid_spacing_m) + 1

    # insert grid points
    points = []
    for r in range(rows):
        y = float(extent.YMin + r * cfg.grid_spacing_m)
        for c in range(cols):
            x = float(extent.XMin + c * cfg.grid_spacing_m)
            if x <= extent.XMax and y <= extent.YMax:
                points.append(arcpy.Point(x, y))

    with arcpy.da.InsertCursor(output_fc, ["SHAPE@"]) as cur:
        for pt in points:
            cur.insertRow([pt])

    initial_count = len(points)
    if initial_count == 0:
        return output_fc, 0, 0

    # if mineral points exists, compute near distance
    if arcpy.Exists(mineral_points_fc) and int(arcpy.GetCount_management(mineral_points_fc)[0]) > 0:
        arcpy.Near_analysis(output_fc, mineral_points_fc)

        # keep NEAR_DIST but remove other near fields after copying
        if "DISTANCE" not in [f.name for f in arcpy.ListFields(output_fc)]:
            arcpy.AddField_management(output_fc, "DISTANCE", "DOUBLE")
        arcpy.CalculateField_management(output_fc, "DISTANCE", "!NEAR_DIST!", "PYTHON3")

        # cleanup near fields
        for f in ["NEAR_FID", "NEAR_DIST"]:
            if f in [ff.name for ff in arcpy.ListFields(output_fc)]:
                arcpy.DeleteField_management(output_fc, [f])

        # apply deletions by zones
        oid = arcpy.Describe(output_fc).OIDFieldName

        for (min_d, max_d, delete_ratio) in cfg.distance_zones:
            where = f"DISTANCE >= {min_d} AND DISTANCE < {max_d}"
            layer = "zone_lyr"
            arcpy.MakeFeatureLayer_management(output_fc, layer, where)
            zone_count = int(arcpy.GetCount_management(layer)[0])
            if zone_count <= 0:
                safe_delete(layer)
                continue

            if delete_ratio >= 1.0:
                arcpy.DeleteFeatures_management(layer)
                safe_delete(layer)
                continue

            # fetch OIDs in zone (deterministic order by OID)
            oids = [row[0] for row in arcpy.da.SearchCursor(layer, [oid], sql_clause=(None, f"ORDER BY {oid}"))]

            if cfg.removal_method == "random":
                delete_count = int(round(zone_count * delete_ratio))
                if delete_count > 0:
                    to_delete = set(random.sample(oids, k=min(delete_count, len(oids))))
                else:
                    to_delete = set()
            else:
                mask = _systematic_keep_mask(len(oids), delete_ratio)
                to_delete = {o for o, keep in zip(oids, mask) if not keep}

            if to_delete:
                # chunk deletes to avoid SQL length issues
                to_delete_list = list(to_delete)
                chunk = 900
                for i in range(0, len(to_delete_list), chunk):
                    sub = to_delete_list[i : i + chunk]
                    oids_csv = ",".join(map(str, sub))
                    del_layer = "del_lyr"
                    arcpy.MakeFeatureLayer_management(output_fc, del_layer, f"{oid} IN ({oids_csv})")
                    arcpy.DeleteFeatures_management(del_layer)
                    safe_delete(del_layer)

            safe_delete(layer)

        # remove DISTANCE field (optional)
        if "DISTANCE" in [f.name for f in arcpy.ListFields(output_fc)]:
            arcpy.DeleteField_management(output_fc, ["DISTANCE"])

    final_count = int(arcpy.GetCount_management(output_fc)[0])
    return output_fc, final_count, initial_count


def run(cfg: NMConfig) -> int:
    configure_logging()
    arcpy.env.overwriteOutput = True
    arcpy.env.workspace = cfg.base_workspace

    ensure_gdb(cfg.output_gdb)

    rasters = list_rasters(cfg)
    pts = list_mineral_point_fcs(cfg)
    pairs = match_pairs(rasters, pts)

    logging.info("Rasters: %d | Mineral point FCs: %d | Matched pairs: %d", len(rasters), len(pts), len(pairs))
    if not pairs:
        logging.error("No matched pairs (height match).")
        return 2

    ok = 0
    for i, pair in enumerate(pairs, 1):
        height = str(pair["height"])
        height_str = height.replace(".", "_")
        out_name = f"n{height_str}"
        out_fc = os.path.join(cfg.output_gdb, out_name)

        logging.info("(%d/%d) Height=%s -> %s", i, len(pairs), height, out_name)
        try:
            out_fc, final_n, init_n = create_fixed_nonmineral_points(
                raster_path=pair["raster"]["path"],
                mineral_points_fc=pair["points"]["path"],
                output_fc=out_fc,
                cfg=cfg,
            )
            logging.info("Created %s | initial=%d | final=%d", out_name, init_n, final_n)
            ok += 1
        except Exception as e:
            logging.exception("Failed %s: %s", out_name, str(e))

    return 0 if ok > 0 else 1


if __name__ == "__main__":
    # ---- EDIT THESE PATHS ----
    cfg = NMConfig(
        base_workspace=r"M:\ Reza\Survey\WGIS\P24_GOSAL\Gosal",
        input_raster_gdb=r"M:\ Reza\Survey\WGIS\P24_GOSAL\Gosal\Litho_Rasters.gdb",
        sample_points_gdb=r"M:\ Reza\Survey\WGIS\P24_GOSAL\Gosal\Gosal.gdb",
        output_gdb=r"M:\ Reza\Survey\WGIS\P24_GOSAL\Gosal\Litho_Rasters.gdb",
        raster_filter_enabled=True,
        raster_filter_text="ColorRaster",
        grid_spacing_m=5.0,
        removal_method="systematic",
    )
    raise SystemExit(run(cfg))
